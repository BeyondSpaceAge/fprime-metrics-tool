#!/usr/bin/env python3

"""
This script gathers a source lines of code (SLOC) per fprime module into a CSV file.
The CSV file can then be ingested into the metricsreport tool in this repository to generate SLOC 
reports.

Requires the nloc program in this repository to be built with 'make'
"""

import sys
import csv
from pathlib import Path
import argparse
from typing import List, Dict, Any
import subprocess


def matches_pattern(path: Path, patterns: List[str]) -> bool:
    for pat in patterns:
        if path.match(pat):
            return True
    return False


def find_files(path: Path, patterns: List[str], ignorelist: List[str] = []):
    matched_files = []
    for pat in patterns:
        for f in path.glob(pat):
            if not matches_pattern(f, ignorelist):
                matched_files.append(f)
    return matched_files


def is_module_dir(path: Path) -> bool:
    cmakelists = path / "CMakeLists.txt"

    if not cmakelists.exists():
        return False

    with open(cmakelists) as f:
        contents = f.read()

        if "register_fprime_module" in contents:
            return True

        if "register_fprime_executable" in contents:
            return True
    return False


def find_modules(path: Path, ignorelist: List[str] = []) -> List[Path]:
    if is_module_dir(path):
        return [path]

    modules = []
    for child in path.iterdir():
        if not child.is_dir() or matches_pattern(child, ignorelist):
            continue

        modules += find_modules(child, ignorelist)
    return modules


def count_sloc_cpp(file: Path) -> int:
    # Run ncsl program in same directory as this script
    proc = subprocess.Popen(
        [Path(__file__).parent.resolve() / "ncsl", str(file)], stdout=subprocess.PIPE
    )
    output = proc.stdout.read().split()
    if len(output) != 14:
        raise ValueError(
            "{}: Unexpected number of elements in ncsl output, expected 14, got {}.".format(
                file, len(output)
            )
        )
    # Return field that represents lines of code without empty lines and comments.
    return int(output[5])


def calc_sloc(
    mod: str, mod_path: Path, root: Path, build_path: Path, ignorelist: List[str] = []
) -> Dict[str, Any]:
    print("Calculating SLOC for", mod)

    cpp_files = find_files(mod_path, ["**/*.cpp", "**/*.hpp"], ignorelist)
    xml_files = find_files(mod_path, ["**/*.xml"], ignorelist)

    ac_files = find_files(build_path / root.name / mod, ["**/*.cpp", "**/*.hpp"])
    # If autocoded files aren't found, assume it's a core fprime module in the  F-Prime subdirectory
    if len(ac_files) == 0:
        ac_files = find_files(build_path / "F-Prime" / mod, ["**/*.cpp", "**/*.hpp"])

    cpp_sloc = 0
    for f in cpp_files:
        file_sloc = count_sloc_cpp(f)
        cpp_sloc += file_sloc
        print("\t{} -> {} SLOC".format(f, file_sloc))

    ac_sloc = 0
    for f in ac_files:
        file_sloc = count_sloc_cpp(f)
        ac_sloc += file_sloc
        print("\t{} -> {} SLOC".format(f, file_sloc))

    xml_sloc = 0
    for f in xml_files:
        file_sloc = sum(1 for _ in open(f))
        xml_sloc += file_sloc
        print("\t{} -> {} SLOC".format(f, file_sloc))

    return {
        "Module": mod,
        "HAND": cpp_sloc,
        "AC": ac_sloc,
        "XML": xml_sloc,
        "TOTAL": cpp_sloc + ac_sloc + xml_sloc,
    }


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Calculate source lines of code of a fprime deployment"
    )
    parser.add_argument(
        "results",
        help="output csv file of results",
    )
    parser.add_argument(
        "platform",
        nargs="?",
        default="native",
        help="Use autogenerated code from specified platform",
    )
    parser.add_argument(
        "--ut",
        action="store_true",
        help="Include SLOC of unit test code in module 'test' subdirectory",
    )
    parser.add_argument(
        "-d",
        "--deployment",
        default=Path.cwd(),
        help="path to specified deployment [default: %(default)s]",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    root = Path(args.deployment)
    mods = find_modules(root, ignorelist=["build-*", "test"])
    mod_names = list(map(lambda m: m.relative_to(root), mods))

    build_folder = "build-fprime-automatic-" + args.platform
    if args.ut:
        build_folder += "-ut"
    build_path = root / build_folder

    if not build_path.exists():
        print(
            "[ERROR] Platform build cache {} not found for platform {}".format(
                build_path, args.platform
            )
        )
        return -1

    ignored_files = []
    if not args.ut:
        ignored_files += [
            "**/test/*",
            "**/test/*/*",
            "**/test/*/*/*",
            "**/test/*/*/*/*",
        ]

    with open(args.results, "w") as csvfile:
        fields = ["Module", "HAND", "AC", "XML", "TOTAL"]
        writer = csv.DictWriter(csvfile, fieldnames=fields)
        writer.writeheader()

        for i in range(len(mods)):
            writer.writerow(
                calc_sloc(str(mod_names[i]), mods[i], root, build_path, ignored_files)
            )

    return 0


if __name__ == "__main__":
    sys.exit(main())
